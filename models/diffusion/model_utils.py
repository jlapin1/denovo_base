import models.diffusion.gaussian_diffusion as gd
from models.diffusion.respace import SpacedDiffusion, space_timesteps

def create_diffusion(
    #class_cond,
    learn_sigma,
    sigma_small,
    sigma_weight,
    diffusion_steps,
    noise_schedule,
    noise_exponent,
    timestep_respacing,
    use_kl,
    predict_xstart,
    rescale_timesteps,
    rescale_learned_sigmas,
    model_arch,
    training_mode,
    sequence_len,
    resume_checkpoint,
    pad_tok_id,
    loss_update_granu,
    schedule_update_stride,
    **kwargs,
):
    diffusion = create_gaussian_diffusion(
        steps=diffusion_steps,
        learn_sigma=learn_sigma,
        sigma_small=sigma_small,
        vlb_weight=sigma_weight,
        noise_schedule=noise_schedule,
        noise_exponent=noise_exponent,
        use_kl=use_kl,
        predict_xstart=predict_xstart,
        rescale_timesteps=rescale_timesteps,
        rescale_learned_sigmas=rescale_learned_sigmas,
        timestep_respacing=timestep_respacing,
        model_arch=model_arch,
        training_mode=training_mode,
        sequence_len=sequence_len,
        resume_checkpoint=resume_checkpoint,
        pad_tok_id=pad_tok_id,
        loss_update_granu=loss_update_granu,
        schedule_update_stride=schedule_update_stride,
    )
    return diffusion

def create_gaussian_diffusion(
    *,
    steps=1000,
    learn_sigma=False,
    sigma_small=False,
    vlb_weight=0.001,
    noise_schedule="linear",
    noise_exponent=0.2,
    use_kl=False,
    predict_xstart=False,
    rescale_timesteps=False,
    rescale_learned_sigmas=False,
    timestep_respacing="",
    model_arch="transformer",
    training_mode="diffusion-lm",
    sequence_len=None,
    resume_checkpoint='',
    pad_tok_id=None,
    loss_update_granu=None,
    schedule_update_stride=0,
):

    betas = gd.get_named_beta_schedule(noise_schedule, steps, exponent=noise_exponent)

    if use_kl:
        loss_type = gd.LossType.E2E_KL
    else:
        loss_type = gd.LossType.E2E_MSE

    if not timestep_respacing:
        timestep_respacing = [steps]

    # Whether variance is learned or fixed
    model_var_type = None
    if not learn_sigma:
        if sigma_small:
            model_var_type = gd.ModelVarType.FIXED_SMALL
        else:
            model_var_type = gd.ModelVarType.FIXED_LARGE
    else:
        model_var_type = gd.ModelVarType.LEARNED_RANGE

    # what is the interpretation of the output generated by the model? Is it generating the noise or the mean directly?

    model_mean_type = None
    if not predict_xstart:
        cmt = "epsilon"
        model_mean_type = gd.ModelMeanType.EPSILON  # predicts noise
    else:  # predicts starting x (x0 estimate, possibly used by DDIM?)
        cmt = "x_start"
        model_mean_type = gd.ModelMeanType.START_X
    print(f"<DIFFCOMMENT> Model mean prediction is {cmt}")

    return SpacedDiffusion(
        use_timesteps=space_timesteps(steps, timestep_respacing),
        betas=betas,
        model_var_type=model_var_type,
        model_mean_type=model_mean_type,
        loss_type=loss_type,
        rescale_timesteps=rescale_timesteps,
        model_arch=model_arch,
        training_mode=training_mode,
        token_max_length=sequence_len,
        save_dir=resume_checkpoint,
        pad_tok_id=pad_tok_id,
        loss_update_granu=loss_update_granu,
        schedule_update_stride=schedule_update_stride,
        vlb_weight=vlb_weight,
    )
